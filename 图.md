# 图

## 基本概念

图的定义：由顶点集V和边集合E组成，记作G=(V,E)，其中V(G)表示图G中顶点的有限非空集合；E(G)表示图G中顶点之间关系的边集合。

1、有向图

2、无向图

3、简单图和多重图

4、完全图

5、子图

6、连通、连通分量(极大连通子图：极大要求子图尽可能包含所有的边)、强连通分量（极大强连通子图）

7、生成树（极小连通子图：图保持连通但是尽可能包含更少的边）、生成森林

8、顶点的度、出度和入度

9、边的权和网（边上带权值的图称为带权图或者网）

10、稠密图和稀疏图(  |E|<|V|log|V|  边数和顶点数的关系)

11、路径、路径长度、回路

12、简单路径、简单回路（不出现重复顶点）

13、距离

14、有向树

## 图的存储

### 存储形式

1、邻接矩阵

```C++
#define maxsize 100
G[maxsize][maxszie]
```

- 在简单应用中，可直接用二维数组作为图的邻接矩阵(顶点信息等均可省略)。

- 当邻接矩阵的元素仅表示相应边是否存在时，可采用值为0和1的枚举类型。

- 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。

  图的邻接矩阵存储表示法具有以下特点:

  1. 无向图的邻接矩阵一定是一 个对称矩阵 (并且唯一)。 因此，在实际存储邻接矩阵时,只需存储上(或下)三角矩阵的元素。
  2. 对于无向图，邻接矩阵的第i行(或第i列)非零元素(或非∞元素)的个数正好是顶点i的度TD。
  3. 对于有向图，邻接矩阵的第i行非零元素(或非∞元素)的个数正好是顶点i的出度OD(v)，第i列非零元素(或非∞元素)的个数正好是顶点i的入度ID(v)。
  4. 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。
  5. 稠密图适合使用邻接矩阵的存储表示。
  6. **设图G的邻接矩阵为A,A^n中位置（i，j）的元素表示由顶点i到顶点j的长度为n的路径的数。**

2、邻接表

```C++
#include <bits/stdc++.h>
/*无向图
test sample
0 1
1 2
1 3
2 4
3 4
2 5
*/
using namespace std;
typedef struct Node{
    int num,weight;
}Node;
vector<Node>q[1001];
typedef struct Arc{
   int num;
   int weight;
   struct Arc *next ;
}Arc;
typedef struct Vex{
    int v;
    Arc *first;
}Vex;
Vex *V[6];
int main()
{
      /**********Vector版本邻接表代码************/
      for(int i=0;i<6;i++){
        int x,y;
        cin>>x>>y;
        Node Node_x;
        Node_x.num=x;
        Node_x.weight=1;
        Node Node_y;
        Node_y.num=y;
        Node_y.weight=1;
        q[x].push_back(Node_y);
        q[y].push_back(Node_x);
     }
     for(int i=0;i<6;i++){
        cout<<"Current Node is:"<<i<<"-->";
        for(int j=0;j<q[i].size();j++){
             cout<<q[i][j].num<<"-->";

        }
        cout<<"NULL"<<endl;
     }
    /**********自定义结构体版本邻接表代码************/
    for(int i=0;i<6;i++){
        V[i]=new Vex;
        V[i]->v=i;
        V[i]->first=NULL;
    }
    for(int i=0;i<6;i++){
        int x,y;
        cin>>x>>y;
        Arc *node_x = new Arc;
        Arc *node_y = new Arc;
        node_x->num=x;
        node_x->weight=1;
        node_y->num=y;
        node_y->weight=1;
        node_y->next=V[x]->first;
        V[x]->first=node_y;
        node_x->next=V[y]->first;
        V[y]->first=node_x;
    }
    for(int i=0;i<6;i++){
        Arc *p=V[i]->first;
        cout<<"Current Node is:"<<i<<"-->";
        while(p){
             cout<<p->num;

             p=p->next;
             if(p){
                cout<<"-->";
             }
             else{
                 cout<<"-->NULL";
             }
        }
        cout<<endl;
    }
    system("pause");
    return 0;
}




```

3、十字链表

4、邻接多重表

## 最小生成树





·
