# 排序算法

排序算法主要考虑算法三个点

1. 时间复杂度
2. 空间复杂度
3. 算法稳定性

## 插入排序

### 直接插入排序

算法思想：往前面已经有序的序列中插入一个数字，这个有序的序列再最开始的时候是只有一个数字（一个数字是认为是有序的序列）

```c++
void InsertSort(int arr[],int n){
    for(int i=1;i<n;i++){
        int j;
        if(arr[i]<arr[i-1]){
            for(j=i-1;j>=0;j--){
                 if(arr[j]>arr[i]){
                      arr[j+1]=arr[j];
                 }
                 else{
                    break;
                }
            }
        }
        arr[j]=arr[i];
    }   
}
```

### 希尔排序

## 选择排序

### 简单选择排序

```c++
void SimpleSort(int arr[],int n){
    for(int i=0;i<n-1;i++){
        int index=i;
        for(int j=i+1;j<n;j++){
            if(arr[j]<=arr[index]){
                index=j;
            }
        }
        if(i!=index){
            swap(arr[i],arr[index]);
        }
    } 
}
```

### 堆排序

## 交换排序

### 冒泡排序

```c++
void BUbbleSort(int arr[],int n){
    for(int i=0;i<n;i++){
        bool flag=true;
        for(int j=0;j<n-i-1;i++){
            if(arr[j]<arr[j+1]){
                swap(arr[j],arr[j+1);
                flag=false;
            }
        }
        if(flag){
             break;
        }
    }
}
```

### 快速排序

```c++
int partaion(int arr[],int left,int right){
    int temp=arr[left]
    while(left<right){
          while(left<right&&temp<arr[right]){
                     right--;
          }
          arr[left]=arr[right];
          while(left<right&&temp>=arr[left]){
                     left++;
          }
          arr[right]=arr[left];
    }
    return left;
}
void QuickSort(int arr[],int left,int right){
    if(left<right){
         int index = partaion(arr,left,right);
          QuickSort(arr,0,index);
          QuickSort(arr,index+1,right);
    }
}
```

## 归并排序

### 归并排序常规

```c++
void Merge(int arr[],int low,int mid,int high){
    int temp[1001];
    int i,j,k;
    for(i=low;i<=high;i++){
        temp[i]=arr[i];//复制一下
    }
    for(k=low,j=low,i=mid+1;j<=mid&&i<=high;){
        if(temp[j]>=temp[i]){
             arr[k++]=temp[i++];
        }
        else{
            arr[k++]=temp[j++];
        }
    }
    while(j<=mid){
        arr[k++]=temp[i++];
    }
    while(i<=high){
        arr[k++]=temp[j++];
    }
}
void MergeSort(int arr[],int low,int high){
    if(low<high){
        int mid=low+(high-low)>>2;
        MergeSort(arr,low,mid);
        MergeSort(arr,mid+1,high);
        Merge(arr,low,mid,high);
    }
    
}
```

### 归并排序算法拓展

- 逆序对问题
- 小数和问题

```c++
/*
    二路归并排序 扩展
    时间：O(nlog2n)
    空间：O(n)
*/
#include <bits/stdc++.h>
#define random(x) (rand()%x)
using namespace std;
int length=9;
int data[10];
int xiaohe=0;
/*随机生成数据*/
void Initdata(){
    for(int i=1;i<=length;i++){
        data[i]=random(100);
    }
}
/*显示数据*/
void display(int n){
    for(int i=1;i<=n;i++){
        cout<<data[i]<<' ';
    }
    cout<<endl;
}
void Merge(int arr[],int low,int mid,int high){
    int temp[1001],i,j,k;
    for(int i=low;i<=high;i++){//先把数据复制一遍
           temp[i]=arr[i];
    }
    for(i=low,j=mid+1,k=low;i<=mid&&j<=high;k++){
        if(temp[i]<temp[j]){
            xiaohe + =temp[i]*(high-j+1);//在这里统计，小数和或者是逆序对数据
            arr[k]=temp[i++];
            // cout<<xiaohe<<endl;
        }
        else{
            arr[k]=temp[j++];
        }
    }
    while(i<=mid){//这两个只有一个会被执行
         arr[k++]=temp[i++];
    }
    while(j<=high){
         arr[k++]=temp[j++];
    }
}
void MergeSort(int arr[],int low,int high){
    if(low<high){
        int mid=(low+high)/2;
        MergeSort(arr,low,mid);
        MergeSort(arr,mid+1,high);
        Merge(arr,low,mid,high);
        //display(length);
    }
}
int main()
{
    int n;
    Initdata();/*随机数生成初始化数据*/
    cout<<"init data list:";
    display(length);
    MergeSort(data,1,length);
    cout<<"res data list:";
    display(length);
    cout<<endl;
    cout<<xiaohe<<endl;   
    system("pause");
    return 0;
}
```

